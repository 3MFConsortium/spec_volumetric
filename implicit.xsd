<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/3dmanufacturing/implicit/2023/02"
	elementFormDefault="unqualified" attributeFormDefault="unqualified" blockDefault="#all"
	xmlns="http://schemas.microsoft.com/3dmanufacturing/implicit/2023/02"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:vol="http://schemas.microsoft.com/3dmanufacturing/volumetric/2022/01">
	<xs:import namespace="http://schemas.microsoft.com/3dmanufacturing/volumetric/2022/01"
		schemaLocation="volumetric.xsd" />
	<xs:annotation>
		<xs:documentation>
			<![CDATA[
		Schema notes:

		Items within this schema follow a simple naming convention of appending a prefix indicating the type of element for references:

		Unprefixed: Element names
		CT_: Complex types
		ST_: Simple types
		
		]]>
		</xs:documentation>
	</xs:annotation>

	<xs:simpleType name="ST_Matrix4x4">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			String containing 16 space seperated floating numbers.
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:QName">
			<xs:pattern
				value="^(-?\d+(\.\d+)?((e|E)[+-]?\d+)?)((\s+-?\d+(\.\d+)?((e|E)[+-]?\d+)?) {15})$" />
		</xs:restriction>
	</xs:simpleType>

	<!-- node is the base type for all nodes in the implicit function tree.	-->
	<xs:complexType name="CT_Node">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Base type for all nodes in the implicit function tree.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="identifier" type="vol:ST_Identifier" use="required" />
		<xs:attribute name="displayname" type="xs:string" use="optional" />
		<xs:attribute name="tag" type="xs:string" use="optional" />
	</xs:complexType>


	<xs:complexType name="CT_Addition">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for an addition with a scalar as output and two scalar inputs or a
			vecotor as output and two vectors as input. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result".
						
			Example:
			<addition identifier="addition1" displayname="Addition 1">
				<in>
								<scalarref identifier="A" ref="constant1.c1"/>
								<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</addition>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the addition.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sum of the added values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant scalar value -->
	<xs:complexType name="CT_ConstantScalar">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant scalar value. The output must have the identifier "value".
			Example:
			<constant identifier="constant1" displayname="Constant 1" value="1.0">
				<out>
					<scalar identifier="value"/>
				</out>
			</constant>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" type="xs:double" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant vector value -->
	<xs:complexType name="CT_ConstantVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant vector value. The output must have the identifier "vector".
			Example:
			<constvec identifier="constant1" displayname="Constant 1" x="1.0" y="2.0" z="3.0">
				<out>
					<vector identifier="vector"/>
				</out>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="x" type="xs:double" use="required" />
				<xs:attribute name="y" type="xs:double" use="required" />
				<xs:attribute name="z" type="xs:double" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant 4x4 matrix value -->
	<xs:complexType name="CT_ConstantMatrix">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant 4x4 matrix value. The output must have the identifier "matrix".
			Example:
			<constmat identifier="constant1" displayname="identity" 
				matrix="1.0 0.0 0.0 0.0
						0.0 1.0 0.0 0.0
						0.0 0.0 1.0 0.0 
						0.0 0.0 0.0 1.0">
				<out>
					<matrix identifier="matrix"/>
				</out>
			</constmat>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="matrix" type="ST_Matrix4x4" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- CT_ResourceID -->
	<xs:complexType name="CT_ConstResourceID">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node that defines a resource id that can be used as an input for a resource reference. The output must have the identifier "value".
			Example:
			<resourceid identifier="resourceid1" displayname="Resource Id 1" value="1">
				<out>
					<resourceid identifier="value"/>
				</out>
			</resourceid>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="value" type="vol:CT_ResourceID" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" type="vol:ST_ResourceID" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- Node for composing a vector from 3 scalar values -->
	<xs:complexType name="CT_ComposeVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a vector from 3 scalar values. The inputs must have the identifiers x, y and z.
			Example:
			<composevector>
				<in>
					<scalarref identifier="x" ref="inputs.x"/>
					<scalarref identifier="y" ref="inputs.y"/>
					<scalarref identifier="z" ref="inputs.z"/>
				</in>
				<out>
					<vector identifier="vector"/>
				</out>
			</composevector>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for decomposing a vector -->
	<xs:complexType name="CT_DecomposeVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for decomposing a vector into 3 scalar values. The input must have the identifier "vector", the outputs must have the identifiers x, y and z.
			Example:
			<decomposevector>
				<in>
					<vectorref identifier="vector" ref="inputs.vector"/>
				</in>
				<out>
					<scalar identifier="x"/>
					<scalar identifier="y"/>
					<scalar identifier="z"/>
				</out>
			</decomposevector>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a matrix from 16 scalar values -->
	<xs:complexType name="CT_ComposeMatrix">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a matrix from 16 scalar values. The inputs must have the following identifiers:
			m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33
			Example:
			<composematrix identifier="composeMatrix_0" displayname="composed matrix">
				<in>
					<scalarref identifier="m00" ref="constantM00.value"/>
					<scalarref identifier="m01" ref="constantM01.value"/>
					<scalarref identifier="m02" ref="constantM02.value"/>
					<scalarref identifier="m03" ref="constantM03.value"/>
					<scalarref identifier="m10" ref="constantM10.value"/>
					<scalarref identifier="m11" ref="constantM11.value"/>
					<scalarref identifier="m12" ref="constantM12.value"/>
					<scalarref identifier="m13" ref="constantM13.value"/>
					<scalarref identifier="m20" ref="constantM20.value"/>
					<scalarref identifier="m21" ref="constantM21.value"/>
					<scalarref identifier="m22" ref="constantM22.value"/>
					<scalarref identifier="m23" ref="constantM23.value"/>
					<scalarref identifier="m30" ref="constantM30.value"/>
					<scalarref identifier="m31" ref="constantM31.value"/>
					<scalarref identifier="m32" ref="constantM32.value"/>
					<scalarref identifier="m33" ref="constantM33.value"/>
				</in>
				<out>
					<matrix identifier="matrix"/>
				</out>
			</composematrix>
			]]>
			
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a Matrix from column vectors -->
	<xs:complexType name="CT_ComposeMatrixFromColumnVectors">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a matrix from column vectors. The 4th row is set [0,0,0,1]. The inputs must have the following identifiers:
			col0, col1, col2, col3.
			Example:
			<composevector identifier="composeMatrixFromColumnVectors" displayname="composed matrix">
				<in>
					<vectorref identifier="col0" ref="vector0.vector"/>
					<vectorref identifier="col1" ref="vector1.vector"/>
					<vectorref identifier="col2" ref="vector2.vector"/>
					<vectorref identifier="col3" ref="vector3.vector"/>
				</in>
				<out>
					<matrix identifier="matrix"/>
				</out>
			</composevector>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a Matrix from row vectors -->
	<xs:complexType name="CT_ComposeMatrixFromRowVectors">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a Matrix from row vectors. The 4th column is set to (0,0,0,1). The inputs must have the following identifiers:
			row0, row1, row2, row3.
			Example:
			<composematrixfromcolumnvectors identifier="composeMatrixFromRowVectors" displayname="composed vector">
				<in>
					<vectorref identifier="row0" ref="vector0.vector"/>
					<vectorref identifier="row1" ref="vector1.vector"/>
					<vectorref identifier="row2" ref="vector2.vector"/>
					<vectorref identifier="row3" ref="vector3.vector"/>
				</in>
				<out>
					<matrix identifier="matrix"/>
				</out>
			</composematrixfromcolumnvectors>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- Nodes for arithmetic operations -->
	<xs:complexType name="CT_Multiplication">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the multiplication A x B = result. The inputs and output can be either scalar, vector or matrix, but must all have the same dimension.
			The inputs must have the identifier "A" and "B", the output must have the identifier "result". If A and B are vectors, the multiplication is done per component.
						
			Example:
			<multiplication identifier="multiplication1" displayname="Multiplication 1">
				<in>
								<scalarref identifier="A" ref="constant1.c1"/>
								<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</multiplication>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the multiplication.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							product of the multiplied values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--subtraction-->
	<xs:complexType name="CT_Subtraction">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a subtraction with a scalar as output and two scalar inputs or a
			vecotor as output and two vectors as input. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result".
						
			Example:
			<subtraction identifier="subtraction1" displayname="Subtraction 1">
				<in>
								<scalarref identifier="A" ref="constant1.c1"/>
								<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</subtraction>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the subtraction.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							difference of the subtracted values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- division-->
	<xs:complexType name="CT_Division">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a division with a scalar as output and two scalar inputs or a
			vecotor as output and two vectors as input. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". For vector inputs the division is componentwise.
						
			Example:
			<division identifier="division1" displayname="Division 1">
				<in>
								<scalarref identifier="A" ref="constant1.c1"/>
								<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</division>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the division.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							quotient of the divided values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- dot product-->
	<xs:complexType name="CT_DotProduct">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a dot product with a scalar as output and two vector inputs. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". 
						
			Example:
			<dot identifier="dotproduct1" displayname="Dot Product 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</dotproduct>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the dot product.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							dot product of the two vectors
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- cross product-->
	<xs:complexType name="CT_CrossProduct">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a cross product with a vector as output and two vector inputs. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result".
						
			Example:
			<cross identifier="crossproduct1" displayname="Cross Product 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</crossp>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the cross product.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							cross product of the two vectors
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Matrix multiplication -->
	<xs:complexType name="CT_MatrixVectorMultiplication">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the matrix vector multiplication A x B = result. The input A must be a matrix and the input B a vector. The output must be a vector with the name "result".
						
			Example:
			<matrixvectormultiplication identifier="matVec1" displayname="Matrix Vector Multiplication 1">
				<in>
								<matrixref identifier="A" ref="inputs.matrix1"/>
								<vectorref identifier="B" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</matrixvectormultiplication>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the matrix vector multiplication.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							product of the matrix and the vector
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Transpose -->
	<xs:complexType name="CT_Transpose">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the transpose of a matrix. The input 'A' must be a matrix and the output must be a matrix with the identifier "result".
						
			Example:
			<transpose identifier="transpose1" displayname="Transpose 1">
				<in>
								<matrixref identifier="A" ref="inputs.matrix1"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</transpose>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the transpose.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							transpose of the matrix
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- sinus function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Sinus">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a sine function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". 
						
			Example:
			<sin identifier="sinus1" displayname="Sinus 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sin>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the sinus function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sinus of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- cosinus function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Cosinus">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a cosinus function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". Input and output must have the same dimension.
						
			Example:
			<cos identifier="cosinus1" displayname="Cosinus 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</cos>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the cosine function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							cosine of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- tan function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Tan">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a tan function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". Input and output must have the same dimension.
						
			Example:
			<tan identifier="tan1" displayname="Tan 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</tan>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the tan function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							tan of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arcsin function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arcsin">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arcsin function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". Input and output must have the same dimension.
						
			Example:
			<arcsin identifier="arcsin1" displayname="Arcsin 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arcsin>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arcsin function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arcsin of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arccos function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arccos">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arccos function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". Input and output must have the same dimension.
						
			Example:
			<arccos identifier="arccos1" displayname="Arccos 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arccos>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arccos function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arccos of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arctan function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arctan">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arctan function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". Input and output must have the same dimension.
						
			Example:
			<arctan identifier="arctan1" displayname="Arctan 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arctan>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arctan function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arctan of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- min function of tow scalars or componentwise of two vectors -->
	<xs:complexType name="CT_Min">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a min function with a scalar or vector as output and two scalars or vectors as input. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". Inputs and output must have the same dimension.
						
			Example:
			<min identifier="min1" displayname="Min 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</min>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the min function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							min of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- max function of tow scalars or componentwise of two vectors -->
	<xs:complexType name="CT_Max">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a max function with a scalar or vector as output and two scalars or vectors as input. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". Inputs and output must have the same dimension.
						
			Example:
			<max identifier="max1" displayname="Max 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</max>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the max function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							max of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- absolute value of a scalar or vector -->
	<xs:complexType name="CT_Abs">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for an absolute value function with a scalar or vector as output and a scalar or vector as input. The input must have the identifier "A",
			the output must have the identifier "result". Inputs and output must have the same dimension.
						
			Example:
			<abs identifier="abs1" displayname="Abs 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</abs>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the absolute value function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							absolute value of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- fmod(A,B) -->
	<xs:complexType name="CT_Fmod">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a fmod function with a scalar or vector as output and two scalars or vectors as input. The input must have the identifier "A" and "B",
			the output must have the identifier "result". Inputs and output must have the same dimension.
						
			Example:
			<fmod identifier="fmod1" displayname="Fmod 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</fmod>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the fmod function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							fmod of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- pow(base,exponent) -->
	<xs:complexType name="CT_Pow">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a pow function with a scalar or vector as output and two scalars or vectors as input. The input must have the identifier "base" and "exponent",
			the output must have the identifier "result". Inputs and output must have the same dimension. In the case of a vector input, the operation is performed element-wise.
						
			Example:
			<pow identifier="pow1" displayname="Pow 1">
				<in>
								<vectorref identifier="base" ref="inputs.vector1"/>
								<vectorref identifier="exponent" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</pow>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the pow function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							pow of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- sqrt(A) -->
	<xs:complexType name="CT_Sqrt">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a sqrt function with a scalar or vector as output and a scalar or vector as input. The input must have the identifier "A",
			the output must have the identifier "result". Inputs and output must have the same dimension. In the case of a vector input, the operation is performed element-wise.
						
			Example:
			<sqrt identifier="sqrt1" displayname="Sqrt 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sqrt>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the sqrt function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sqrt of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- distance to mesh -->
	<xs:complexType name="CT_SignedDistanceToMesh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for evaluating the signed distance to a mesh. The input must have the identifier "point" and must be a vector. The output is a scalar and must have the identifier "distance".
			The mesh is defined by a resource identifier. The mesh is assumed to be closed and watertight. 
			The distance is positive if the point is outside the mesh and negative if the point is inside the mesh.
									
			Example:
			<mesh identifier="distanceToMesh1" displayname="Distance to Mesh 1" objectid="1" >
				<in>
								<vectorref identifier="pos" ref="inputs.pos"/>
								<resourceref identifier="mesh" ref="2"/>
				</in>
				<out>
					<scalar identifier="distance"/>
				</out>
			</mesh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the distance to mesh function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="resourceref" type="vol:ST_ResourceID" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							distance to mesh of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="objectid" type="vol:ST_ResourceID" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- length of a vector -->
	<xs:complexType name="CT_Length">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a length function with a scalar as output and a vector as input. The input must have the identifier "X",
			the output must have the identifier "result".
						
			Example:
			<length identifier="length1" displayname="Length 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</length>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the length function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							length of the input vector
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="CT_ImplicitFunction">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a function with an arbitrary number of inputs and outputs. The inputs and outputs are defined by the user.
			
			Example:
			<implicitfunction identifier="sphere" displayname="Sphere">
				<in>
					<vector	identifier="coordinates" displayname="Coordinates"/>
					<scalar identifier="radius" displayname="radius"/>
				</in>
					
				<length identifier="length1" displayname="length1">
					<in>
						<vectorref identifier="coordinates" ref="inputs.coordinates"/>
					</in>
					<out>
						<scalar identifier="value" displayname="length"></scalar>
					</out>
				</length>
				
				<subtraction identifier="sub1" displayname="subtraction">
					<in>
						<scalarref identifier="A" ref="lentgth1.value"/>
						<scalarref identifier="B" ref="inputs.radius"/>
					</in>
					<out>
						<scalar identifier="difference" displayname="difference"></scalar>
					</out>
				</subtraction>
				
				<outputs>
					<vectoref identifier="distance" ref="sub1.difference">
				</outputs>
			</function>

			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="vol:CT_Function">
				<xs:sequence>
					<!-- nodes -->
					<xs:element name="addition" type="CT_Addition" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="subtraction" type="CT_Subtraction" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="multiplication" type="CT_Multiplication" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="division" type="CT_Division" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constant" type="CT_ConstantScalar" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constvec" type="CT_ConstantVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constmat" type="CT_ConstantMatrix" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="composevector" type="CT_ComposeVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="decomposevector" type="CT_DecomposeVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="composematrix" type="CT_ComposeMatrix" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="composematrixfromcolumnvectors"
						type="CT_ComposeMatrixFromColumnVectors" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="dot" type="CT_DotProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="cross" type="CT_CrossProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="matvecmultiplication" type="CT_MatrixVectorMultiplication"
						minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="transpose" type="CT_Transpose" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="sin" type="CT_Sinus" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="cos" type="CT_Cosinus" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="tan" type="CT_Tan" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="arcsin" type="CT_Arcsin" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="arccos" type="CT_Arccos" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="arctan" type="CT_Arctan" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="min" type="CT_Min" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="max" type="CT_Max" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="abs" type="CT_Abs" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="fmod" type="CT_Fmod" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="pow" type="CT_Pow" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="sqrt" type="CT_Sqrt" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="functioncall" type="CT_FunctionCall" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="dot" type="CT_DotProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="cross" type="CT_CrossProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="mesh" type="CT_SignedDistanceToMesh" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="length" type="CT_Length" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="resourceid" type="CT_ConstResourceID" minOccurs="0"
						maxOccurs="unbounded" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- node for calling a function -->
	<xs:complexType name="CT_FunctionCall">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Calls a function. It must at least have an functionref input with the identifier "functionID".
			Example:
			<functioncall identifier="sphere" displayname="Sphere">
				<in>
					<functionref identifier="functionID" ref="functionIDNode.value" />
					<scalarref identifier="pos" ref="othernode_0.result" />
					<scalarref identifier="radius" ref="othernode_1.result" />
				</in>
				<out>
					<scalarref identifer="result" ref="mySphereFunction.distance"/>
				</out>
			</functioncall>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="unbounded">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="functionref" type="vol:CT_FunctionRef"
									minOccurs="1"
									maxOccurs="1" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							References to the outputs of the function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" minOccurs="0"
									maxOccurs="unbounded" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="implicitfunction" type="CT_ImplicitFunction"/>
</xs:schema>