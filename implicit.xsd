<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://schemas.microsoft.com/3dmanufacturing/implicit/2023/12"
	elementFormDefault="unqualified" attributeFormDefault="unqualified" blockDefault="#all"
	xmlns="http://schemas.microsoft.com/3dmanufacturing/implicit/2023/12"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:vol="http://schemas.microsoft.com/3dmanufacturing/volumetric/2022/01">
	<xs:import namespace="http://schemas.microsoft.com/3dmanufacturing/volumetric/2022/01"
		schemaLocation="volumetric.xsd" />
	
	<xs:annotation>
		<xs:documentation>
			<![CDATA[
		Schema notes:

		Items within this schema follow a simple naming convention of appending a prefix indicating the type of element for references:

		Unprefixed: Element names
		CT_: Complex types
		ST_: Simple types
		
		]]>
		</xs:documentation>
	</xs:annotation>

	<xs:simpleType name="ST_Matrix4x4">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			String containing 16 space seperated floating numbers.
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:QName">
			<xs:pattern
				value="^(-?\d+(\.\d+)?((e|E)[+-]?\d+)?)((\s+-?\d+(\.\d+)?((e|E)[+-]?\d+)?) {15})$" />
		</xs:restriction>
	</xs:simpleType>

	<!-- node is the base type for all nodes in the implicit function tree.	-->
	<xs:complexType name="CT_Node">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Base type for all nodes in the implicit function tree.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="identifier" type="vol:ST_Identifier" use="required" />
		<xs:attribute name="displayname" type="xs:string" use="optional" />
		<xs:attribute name="tag" type="xs:string" use="optional" />
	</xs:complexType>


	<xs:complexType name="CT_Addition">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for an addition. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- scalar + scalar = scalar
			- vector + vector = vector (vector is added componentwise)
			- matrix + matrix = matrix (matrix is added componentwise)
						
			Example:
			<addition identifier="addition1" displayname="Addition 1">
				<in>
								<scalarref identifier="A" ref="constant1.c1"/>
								<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</addition>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the addition.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sum of the added values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant scalar value -->
	<xs:complexType name="CT_ConstantScalar">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant scalar value. The output must have the identifier "value".
			Example:
			<constant identifier="constant1" displayname="Constant 1" value="1.0">
				<out>
					<scalar identifier="value"/>
				</out>
			</constant>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" type="xs:double" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant vector value -->
	<xs:complexType name="CT_ConstantVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant vector value. The output must have the identifier "vector".
			Example:
			<constvec identifier="constant1" displayname="Constant 1" x="1.0" y="2.0" z="3.0">
				<out>
					<vector identifier="vector"/>
				</out>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="x" type="xs:double" use="required" />
				<xs:attribute name="y" type="xs:double" use="required" />
				<xs:attribute name="z" type="xs:double" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for a constant 4x4 matrix value -->
	<xs:complexType name="CT_ConstantMatrix">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for a constant 4x4 matrix value. The output must have the identifier "matrix".
			Example:
			<constmat identifier="constant1" displayname="identity" 
				matrix="1.0 0.0 0.0 0.0
						0.0 1.0 0.0 0.0
						0.0 0.0 1.0 0.0 
						0.0 0.0 0.0 1.0">
				<out>
					<matrix identifier="matrix"/>
				</out>
			</constmat>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="matrix" type="ST_Matrix4x4" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- CT_ResourceID -->
	<xs:complexType name="CT_ConstResourceID">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node that defines a resource id that can be used as an input for a resource reference. The output must have the identifier "value".
			Example:
			<resourceid identifier="resourceid1" displayname="Resource Id 1" value="1">
				<out>
					<resourceid identifier="value"/>
				</out>
			</resourceid>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="value" type="vol:CT_ResourceID" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="value" type="vol:ST_ResourceID" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- Node for composing a vector from 3 scalar values -->
	<xs:complexType name="CT_ComposeVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a vector from 3 scalar values. The inputs must have the identifiers x, y and z.
			Example:
			<composevector>
				<in>
					<scalarref identifier="x" ref="inputs.x"/>
					<scalarref identifier="y" ref="inputs.y"/>
					<scalarref identifier="z" ref="inputs.z"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</composevector>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

		<!-- Node for creating a vector from a single scalar value -->
		<xs:complexType name="CT_VectorFromScalar">
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
				Node for creating a vector from a single scalar value. The input must have the identifier "A".
				Example:
				<vectorfromscalar>
					<in>
						<scalarref identifier="A" ref="inputs.x"/>
					</in>
					<out>
						<vector identifier="result"/>
					</out>
				</composevector>
				]]>
				</xs:documentation>
			</xs:annotation>
			<xs:complexContent>
				<xs:extension base="CT_Node">
					<xs:sequence>
						<xs:element name="in" minOccurs="1" maxOccurs="1">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								</xs:sequence>
							</xs:complexType>
						</xs:element>
						<xs:element name="out" minOccurs="1" maxOccurs="1">
							<xs:complexType>
								<xs:sequence>
									<xs:element name="vector" type="vol:CT_Vector" />
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>

	<!-- Node for decomposing a vector -->
	<xs:complexType name="CT_DecomposeVector">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for decomposing a vector into 3 scalar values. The input must have the identifier "A", the outputs must have the identifiers x, y and z.
			Example:
			<decomposevector>
				<in>
					<vectorref identifier="A" ref="inputs.vector"/>
				</in>
				<out>
					<scalar identifier="x"/>
					<scalar identifier="y"/>
					<scalar identifier="z"/>
				</out>
			</decomposevector>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a matrix from 16 scalar values -->
	<xs:complexType name="CT_ComposeMatrix">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a matrix from 16 scalar values. The inputs must have the following identifiers:
			m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33
			Example:
			<composematrix identifier="composeMatrix_0" displayname="composed matrix">
				<in>
					<scalarref identifier="m00" ref="constantM00.value"/>
					<scalarref identifier="m01" ref="constantM01.value"/>
					<scalarref identifier="m02" ref="constantM02.value"/>
					<scalarref identifier="m03" ref="constantM03.value"/>
					<scalarref identifier="m10" ref="constantM10.value"/>
					<scalarref identifier="m11" ref="constantM11.value"/>
					<scalarref identifier="m12" ref="constantM12.value"/>
					<scalarref identifier="m13" ref="constantM13.value"/>
					<scalarref identifier="m20" ref="constantM20.value"/>
					<scalarref identifier="m21" ref="constantM21.value"/>
					<scalarref identifier="m22" ref="constantM22.value"/>
					<scalarref identifier="m23" ref="constantM23.value"/>
					<scalarref identifier="m30" ref="constantM30.value"/>
					<scalarref identifier="m31" ref="constantM31.value"/>
					<scalarref identifier="m32" ref="constantM32.value"/>
					<scalarref identifier="m33" ref="constantM33.value"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</composematrix>
			]]>
			
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a Matrix from column vectors -->
	<xs:complexType name="CT_MatrixFromColumns">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a matrix from column vectors. The 4th row is set [0,0,0,1]. The inputs must have the following identifiers:
			A, B, C, D.
			Example:
			<matrixfromcolumns identifier="matrixfromcolumns" displayname="composed matrix">
				<in>
					<vectorref identifier="A" ref="vector0.vector"/>
					<vectorref identifier="B" ref="vector1.vector"/>
					<vectorref identifier="C" ref="vector2.vector"/>
					<vectorref identifier="D" ref="vector3.vector"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</matrixfromcolumns>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Node for composing a Matrix from row vectors -->
	<xs:complexType name="CT_MatrixFromRows">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for composing a Matrix from row vectors. The 4th column is set to (0,0,0,1). The inputs must have the following identifiers:
			A, B, C, D.
			Example:
			<matrixfromrows identifier="matrixfromrows" displayname="composed matrix">
				<in>
					<vectorref identifier="A" ref="vector0.vector"/>
					<vectorref identifier="B" ref="vector1.vector"/>
					<vectorref identifier="C" ref="vector2.vector"/>
					<vectorref identifier="D" ref="vector3.vector"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</matrixfromrows>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- Nodes for arithmetic operations -->
	<xs:complexType name="CT_Multiplication">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the multiplication A x B = result.
			The inputs must have the identifier "A" and "B", the output must have the identifier "result". If only one of the inputs is a scalar, the operation is componentwise. The following combinations of inputs and outputs are allowed:
			- scalar * scalar = scalar
			- vector * vector = vector (vector is multiplied componentwise)
			- matrix * matrix = matrix (matrix is multiplied componentwise)

			Example:
			<multiplication identifier="multiplication1" displayname="Multiplication 1">
				<in>
					<scalarref identifier="A" ref="constant1.c1"/>
					<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</multiplication>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the multiplication.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							product of the multiplied values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!--subtraction-->
	<xs:complexType name="CT_Subtraction">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a subtraction. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- scalar - scalar = scalar
			- vector - vector = vector (vector is subtracted componentwise)
			- matrix - matrix = matrix (matrix is subtracted componentwise)
						
			Example:
			<subtraction identifier="subtraction1" displayname="Subtraction 1">
				<in>
					<scalarref identifier="A" ref="constant1.c1"/>
					<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</subtraction>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the subtraction.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							difference of the subtracted values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- division-->
	<xs:complexType name="CT_Division">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a division. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- scalar / scalar = scalar
			- vector / vector = vector (vector is divided componentwise)
			- matrix / matrix = matrix (matrix is divided componentwise)
						
			Example:
			<division identifier="division1" displayname="Division 1">
				<in>
					<scalarref identifier="A" ref="constant1.c1"/>
					<scalarref identifier="B" ref="inputs.radius"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</division>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the division.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							quotient of the divided values
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- dot product-->
	<xs:complexType name="CT_DotProduct">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a dot product with a scalar as output and two vector inputs. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- vector * vector = scalar (dot product of the two vectors)
						
			Example:
			<dot identifier="dotproduct1" displayname="Dot Product 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</dotproduct>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the dot product.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							dot product of the two vectors
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- cross product-->
	<xs:complexType name="CT_CrossProduct">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a cross product. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- vector x vector = vector (cross product of the two vectors)
						
			Example:
			<cross identifier="crossproduct1" displayname="Cross Product 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</crossp>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the cross product.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							cross product of the two vectors
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Matrix multiplication -->
	<xs:complexType name="CT_MatrixVectorMultiplication">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the matrix vector multiplication A x B = result. The output must be a vector with the name "result". The following combinations of inputs and outputs are allowed:
			- matrix * vector = vector
						
			Example:
			<matrixvectormultiplication identifier="matVec1" displayname="Matrix Vector Multiplication 1">
				<in>
					<matrixref identifier="A" ref="inputs.matrix1"/>
					<vectorref identifier="B" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</matrixvectormultiplication>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the matrix vector multiplication.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:choice>
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:choice>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							product of the matrix and the vector
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Transpose -->
	<xs:complexType name="CT_Transpose">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Performs the transpose of a matrix. The input 'A' must be a matrix and the output must be a matrix with the identifier "result".
						
			Example:
			<transpose identifier="transpose1" displayname="Transpose 1">
				<in>
					<matrixref identifier="A" ref="inputs.matrix1"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</transpose>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the transpose.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							transpose of the matrix
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- Inverse -->
	<xs:complexType name="CT_Inverse">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Computes the inverse of a matrix. The input 'A' must be a matrix and the output must be a matrix with the identifier "result".
						
			Example:
			<inverse identifier="inverse1" displayname="Inverse 1">
				<in>
					<matrixref identifier="A" ref="inputs.matrix1"/>
				</in>
				<out>
					<matrix identifier="result"/>
				</out>
			</inverse>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the inverse.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							inverse of the matrix
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- sinus function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Sinus">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a sine function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- sin(scalar) = scalar
			- sin(vector) = vector (sine of each component of the vector)
						
			Example:
			<sin identifier="sinus1" displayname="Sinus 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sin>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the sinus function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sinus of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- cosinus function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Cosinus">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a cosinus function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- cos(scalar) = scalar
			- cos(vector) = vector (cosinus of each component of the vector)
						
			Example:
			<cos identifier="cosinus1" displayname="Cosinus 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</cos>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the cosine function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							cosine of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- tan function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Tan">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a tan function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- tan(scalar) = scalar
			- tan(vector) = vector (tan of each component of the vector)
						
			Example:
			<tan identifier="tan1" displayname="Tan 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</tan>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the tan function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							tan of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arcsin function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arcsin">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arcsin function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- arcsin(scalar) = scalar
			- arcsin(vector) = vector (arcsin of each component of the vector)
						
			Example:
			<arcsin identifier="arcsin1" displayname="Arcsin 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arcsin>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arcsin function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arcsin of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arccos function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arccos">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arccos function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- arccos(scalar) = scalar
			- arccos(vector) = vector (arccos of each component of the vector)
						
			Example:
			<arccos identifier="arccos1" displayname="Arccos 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arccos>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arccos function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arccos of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- arctan function for scalars or componentwise for vectors -->
	<xs:complexType name="CT_Arctan">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arctan function with a scalar or vector as output and a scalar or vector input. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- arctan(scalar) = scalar
			- arctan(vector) = vector (arctan of each component of the vector)
						
			Example:
			<arctan identifier="arctan1" displayname="Arctan 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arctan>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arctan function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							arctan of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- arctan2 function -->
	<xs:complexType name="CT_Arctan2">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a arctan2 function. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- arctan2(scalar,scalar) = scalar
			- arctan2(vector,vector) = vector (arctan2 of each component of the vectors)
						
			Example:
			<arctan2 identifier="arctan21" displayname="Arctan2 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</arctan2>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="2" maxOccurs="2">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the arctan2 function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
									arctan2 of the input
									]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- min function -->
	<xs:complexType name="CT_Min">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a min function. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- min(scalar,scalar) = scalar
			- min(vector,vector) = vector (min of each component of the vectors)
			- min(matrix,matrix) = matrix (min of each component of the matrices)
						
			Example:
			<min identifier="min1" displayname="Min 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</min>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the min function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							min of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- max function -->
	<xs:complexType name="CT_Max">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a max function. The inputs must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- min(scalar,scalar) = scalar
			- min(vector,vector) = vector (min of each component of the vectors)
			- min(matrix,matrix) = matrix (min of each component of the matrices)
						
			Example:
			<max identifier="max1" displayname="Max 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</max>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the max function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							max of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- absolute value  -->
	<xs:complexType name="CT_Abs">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for an absolute value function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- abs(scalar) = scalar
			- abs(vector) = vector (absolute value of each component of the vector)
			- abs(matrix) = matrix (absolute value of each component of the matrix)
						
			Example:
			<abs identifier="abs1" displayname="Abs 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</abs>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the absolute value function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							absolute value of the input
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- fmod(A,B) -->
	<xs:complexType name="CT_Fmod">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a fmod function. The input must have the identifier "A" and "B",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- fmod(scalar,scalar) = scalar
			- fmod(vector,vector) = vector (fmod of each component of the vectors)
			- fmod(matrix,matrix) = matrix (fmod of each component of the matrices)
						
			Example:
			<fmod identifier="fmod1" displayname="Fmod 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</fmod>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the fmod function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							fmod of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- pow(base,exponent) -->
	<xs:complexType name="CT_Pow">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a pow function. The input must have the identifier "A" (base) and "B" (exponent),
			the output must have the identifier "result". Inputs and output must have the same dimension. The following combinations of inputs and outputs are allowed:
			- pow(scalar,scalar) = scalar
			- pow(vector,vector) = vector (pow of each component of the vectors)
			- pow(matrix,matrix) = matrix (pow of each component of the matrices)
						
			Example:
			<pow identifier="pow1" displayname="Pow 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="B" ref="inputs.vector2"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</pow>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the pow function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							pow of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- sqrt(A) -->
	<xs:complexType name="CT_Sqrt">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a sqrt function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- sqrt(scalar) = scalar
			- sqrt(vector) = vector (sqrt of each component of the vector)
			- sqrt(matrix) = matrix (sqrt of each component of the matrix)
						
			Example:
			<sqrt identifier="sqrt1" displayname="Sqrt 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sqrt>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the sqrt function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							sqrt of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- distance to mesh -->
	<xs:complexType name="CT_SignedDistanceToMesh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for evaluating the signed distance to a mesh. The input must have the identifier "pos" and must be a vector. The output is a scalar and must have the identifier "distance".
			The mesh is defined by a resource identifier. The mesh is assumed to be closed and watertight. 
			The distance is positive if the point is outside the mesh and negative if the point is inside the mesh.
									
			Example:
			<mesh identifier="distanceToMesh1" displayname="Distance to Mesh 1" objectid="1" >
				<in>
					<vectorref identifier="pos" ref="inputs.pos"/>
					<resourceref identifier="mesh" ref="resourceidnode.value"/>
				</in>
				<out>
					<scalar identifier="distance"/>
				</out>
			</mesh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the distance to mesh function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="resourceref" type="vol:ST_ResourceID" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							distance to mesh of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="objectid" type="vol:ST_ResourceID" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- unsigned distance to mesh -->
	<xs:complexType name="CT_UnsignedDistanceToMesh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Node for evaluating the unsigned distance to a mesh. The input must have the identifier "pos" and must be a vector. The output is a scalar and must have the identifier "distance".
			The mesh is defined by a resource identifier. The mesh may be be open and is not required to be watertight. 
			The distance is positive if the point is outside the mesh and negative if the point is inside the mesh.
									
			Example:
			<unsignedmesh identifier="UnsigendDistanceToMesh1" displayname="Unsigned Distance to Mesh 1" objectid="1" >
				<in>
					<vectorref identifier="pos" ref="inputs.pos"/>
					<resourceref identifier="mesh" ref="resourceidnode.value"/>
				</in>
				<out>
					<scalar identifier="distance"/>
				</out>
			</unsignedmesh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the distance to mesh function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="resourceref" type="vol:ST_ResourceID" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							unsigned distance to mesh of the inputs
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="objectid" type="vol:ST_ResourceID" use="required" />
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- length of a vector -->
	<xs:complexType name="CT_Length">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a length function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- length(vector) = scalar
						
			Example:
			<length identifier="length1" displayname="Length 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<scalar identifier="result"/>
				</out>
			</length>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the length function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							length of the input vector
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- base for log, exp etc. -->
	<xs:complexType name="CT_BaseOneParameterFunc">
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
									result of the function
									]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- natural log-->
	<xs:complexType name="CT_Log">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a natural log function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- log(scalar) = scalar
			- log(vector) = vector (ln of each component of the vector)
			- log(matrix) = matrix (ln of each component of the matrix)
						
			Example:
			<log identifier="log_1" displayname="Log_n 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</ln>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- log2 -->
	<xs:complexType name="CT_Log2">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a log2 function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- log2(scalar) = scalar
			- log2(vector) = vector (log2 of each component of the vector)
			- log2(matrix) = matrix (log2 of each component of the matrix)
						
			Example:
			<log2 identifier="log21" displayname="Log2 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</log2>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- log10 -->
	<xs:complexType name="CT_Log10">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a log10 function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- log10(scalar) = scalar
			- log10(vector) = vector (log10 of each component of the vector)
			- log10(matrix) = matrix (log10 of each component of the matrix)
						
			Example:
			<log10 identifier="log101" displayname="Log10 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</log10>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- exp -->
	<xs:complexType name="CT_Exp">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for an exponential function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- exp(scalar) = scalar
			- exp(vector) = vector (exp of each component of the vector)
			- exp(matrix) = matrix (exp of each component of the matrix)
						
			Example:
			<exp identifier="exp1" displayname="Exp 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</exp>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- cosh-->
	<xs:complexType name="CT_Cosh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a hyperbolic cosine function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- cosh(scalar) = scalar
			- cosh(vector) = vector (cosh of each component of the vector)
			- cosh(matrix) = matrix (cosh of each component of the matrix)
						
			Example:
			<cosh identifier="cosh1" displayname="Cosh 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</cosh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- sinh-->
	<xs:complexType name="CT_Sinh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a hyperbolic sine function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- sinh(scalar) = scalar
			- sinh(vector) = vector (sinh of each component of the vector)
			- sinh(matrix) = matrix (sinh of each component of the matrix)
						
			Example:
			<sinh identifier="sinh1" displayname="Sinh 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sinh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- tanh-->
	<xs:complexType name="CT_Tanh">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a hyperbolic tangent function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- tanh(scalar) = scalar
			- tanh(vector) = vector (tanh of each component of the vector)
			- tanh(matrix) = matrix (tanh of each component of the matrix)
						
			Example:
			<tanh identifier="tanh1" displayname="Tanh 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</tanh>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- clamp -->
	<xs:complexType name="CT_Clamp">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a clamp function max(min, min(A,max)). The input must have the identifier "A" (value), "min" and "max",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- clamp(scalar,scalar,scalar) = scalar
			- clamp(vector,vector,vector) = vector (clamp of each component of the vectors)
			- clamp(matrix,matrix,matrix) = matrix (clamp of each component of the matrices)			
			Example:
			<clamp identifier="clamp1" displayname="Clamp 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
					<vectorref identifier="min" ref="inputs.vector2"/>
					<vectorref identifier="max" ref="inputs.vector3"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</clamp>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the clamp function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
									result of clamp(value,min,max)
									]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
								<xs:element name="matrix" type="vol:CT_Matrix" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- select -->
	<xs:complexType name="CT_Select">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a select function. The input must have the identifier "A", "B", "C", "D",
			the output must have the identifier "result". If A < B then the result is C, otherwise D. The following combinations of inputs and outputs are allowed:
			- select(scalar,scalar,scalar,scalar) = scalar
			- select(vector,vector,vector,vector) = vector (select of each component of the vectors)
			- select(matrix,matrix,matrix,matrix) = matrix (select of each component of the matrices)

			Example:
			<select identifier="select1" displayname="Select 1">
				<in>
								<vectorref identifier="A" ref="inputs.vector1"/>
								<vectorref identifier="B" ref="inputs.vector2"/>
								<vectorref identifier="C" ref="inputs.vector3"/>
								<vectorref identifier="D" ref="inputs.vector4"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</select>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the select function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
									result of A < B ? C : D
									]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" />
								<xs:element name="vector" type="vol:CT_Vector" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- round -->
	<xs:complexType name="CT_Round">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a round function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- round(scalar) = scalar
			- round(vector) = vector (round of each component of the vector)
			- round(matrix) = matrix (round of each component of the matrix)
						
			Example:
			<round identifier="round1" displayname="Round 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</round>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- ceil-->
	<xs:complexType name="CT_Ceil">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a ceil function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- ceil(scalar) = scalar
			- ceil(vector) = vector (ceil of each component of the vector)
			- ceil(matrix) = matrix (ceil of each component of the matrix)
						
			Example:
			<ceil identifier="ceil1" displayname="Ceil 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</ceil>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- floor -->
	<xs:complexType name="CT_Floor">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a floor function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- floor(scalar) = scalar
			- floor(vector) = vector (floor of each component of the vector)
			- floor(matrix) = matrix (floor of each component of the matrix)
						
			Example:
			<floor identifier="floor1" displayname="Floor 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</floor>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- sign -->
	<xs:complexType name="CT_Sign">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a sign function. The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- sign(scalar) = scalar
			- sign(vector) = vector (sign of each component of the vector)
			- sign(matrix) = matrix (sign of each component of the matrix)
						
			Example:
			<sign identifier="sign1" displayname="Sign 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sign>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- fract(A) -->
	<xs:complexType name="CT_Fract">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Returns the fractional part of the input (A- floor(A)). The input must have the identifier "A",
			the output must have the identifier "result". The following combinations of inputs and outputs are allowed:
			- sign(scalar) = scalar
			- sign(vector) = vector (sign of each component of the vector)
			- sign(matrix) = matrix (sign of each component of the matrix)
						
			Example:
			<sign identifier="sign1" displayname="Sign 1">
				<in>
					<vectorref identifier="A" ref="inputs.vector1"/>
				</in>
				<out>
					<vector identifier="result"/>
				</out>
			</sign>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_BaseOneParameterFunc">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>


	<!-- implicit function -->
	<xs:complexType name="CT_ImplicitFunction">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Derived node for a function with an arbitrary number of inputs and outputs. The inputs and outputs are defined by the user.
			
			Example:
			<implicitfunction identifier="sphere" displayname="Sphere">
				<in>
					<vector	identifier="coordinates" displayname="Coordinates"/>
					<scalar identifier="radius" displayname="radius"/>
				</in>
					
				<length identifier="length1" displayname="length1">
					<in>
						<vectorref identifier="coordinates" ref="inputs.coordinates"/>
					</in>
					<out>
						<scalar identifier="value" displayname="length"></scalar>
					</out>
				</length>
				
				<subtraction identifier="sub1" displayname="subtraction">
					<in>
						<scalarref identifier="A" ref="lentgth1.value"/>
						<scalarref identifier="B" ref="inputs.radius"/>
					</in>
					<out>
						<scalar identifier="difference" displayname="difference"></scalar>
					</out>
				</subtraction>
				
				<outputs>
					<vectoref identifier="distance" ref="sub1.difference">
				</outputs>
			</function>

			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="vol:CT_Function">
				<xs:sequence>
					<!-- nodes -->
					<xs:element name="addition" type="CT_Addition" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="subtraction" type="CT_Subtraction" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="multiplication" type="CT_Multiplication" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="division" type="CT_Division" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constant" type="CT_ConstantScalar" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constvec" type="CT_ConstantVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="constmat" type="CT_ConstantMatrix" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="composevector" type="CT_ComposeVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="vectorfromscalar" type="CT_VectorFromScalar" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="decomposevector" type="CT_DecomposeVector" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="composematrix" type="CT_ComposeMatrix" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="matrixfromcolumns"
						type="CT_MatrixFromColumns" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="matrixfromrows"
						type="CT_MatrixFromRows" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="dot" type="CT_DotProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="cross" type="CT_CrossProduct" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="matvecmultiplication" type="CT_MatrixVectorMultiplication"
						minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="transpose" type="CT_Transpose" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="inverse" type="CT_Inverse" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="sin" type="CT_Sinus" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="cos" type="CT_Cosinus" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="tan" type="CT_Tan" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="arcsin" type="CT_Arcsin" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="arccos" type="CT_Arccos" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="arctan" type="CT_Arctan" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="arctan2" type="CT_Arctan2" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="min" type="CT_Min" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="max" type="CT_Max" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="abs" type="CT_Abs" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="fmod" type="CT_Fmod" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="pow" type="CT_Pow" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="sqrt" type="CT_Sqrt" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="exp" type="CT_Exp" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="log" type="CT_Log" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="log2" type="CT_Log2" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="log10" type="CT_Log10" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="select" type="CT_Select" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="clamp" type="CT_Clamp" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="cosh" type="CT_Cosh" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="sinh" type="CT_Sinh" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="tanh" type="CT_Tanh" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="round" type="CT_Round" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="ceil" type="CT_Ceil" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="floor" type="CT_Floor" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="sign" type="CT_Sign" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="fract" type="CT_Fract" minOccurs="0" maxOccurs="unbounded" />
					<xs:element name="functioncall" type="CT_FunctionCall" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="mesh" type="CT_SignedDistanceToMesh" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="unsignedmesh" type="CT_UnsignedDistanceToMesh" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="length" type="CT_Length" minOccurs="0"
						maxOccurs="unbounded" />
					<xs:element name="resourceid" type="CT_ConstResourceID" minOccurs="0"
						maxOccurs="unbounded" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<!-- node for calling a function -->
	<xs:complexType name="CT_FunctionCall">
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
			Calls a function. It must at least have an resourceref input with the identifier "functionID".
			Example:
			<functioncall identifier="sphere" displayname="Sphere">
				<in>
					<resourceref identifier="functionID" ref="functionIDNode.value" />
					<scalarref identifier="pos" ref="othernode_0.result" />
					<scalarref identifier="radius" ref="othernode_1.result" />
				</in>
				<out>
					<scalarref identifer="result" ref="mySphereFunction.distance"/>
				</out>
			</functioncall>
			]]>
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CT_Node">
				<xs:sequence>
					<xs:element name="in" minOccurs="1" maxOccurs="unbounded">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
							Inputs to the function.
							]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalarref" type="vol:CT_ScalarRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="vectorref" type="vol:CT_VectorRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="matrixref" type="vol:CT_MatrixRef" minOccurs="0"
									maxOccurs="unbounded" />
								<xs:element name="resourceref" type="vol:CT_ResourceRef"
									minOccurs="1"
									maxOccurs="1" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="out" minOccurs="1" maxOccurs="1">
						<xs:complexType>
							<xs:annotation>
								<xs:documentation>
									<![CDATA[
									Outputs of the function.
									]]>
								</xs:documentation>
							</xs:annotation>
							<xs:sequence>
								<xs:element name="scalar" type="vol:CT_Scalar" minOccurs="0"
								maxOccurs="unbounded" />
								<xs:element name="vector" type="vol:CT_Vector" minOccurs="0"
								maxOccurs="unbounded" />
								<xs:element name="matrix" type="vol:CT_Matrix" minOccurs="0"
								maxOccurs="unbounded" />
								<xs:element name="resourceid" type="vol:CT_ResourceID" minOccurs="0"
								maxOccurs="unbounded" />
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="implicitfunction" type="CT_ImplicitFunction" />
</xs:schema>